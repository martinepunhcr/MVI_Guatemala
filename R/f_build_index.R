# WARNING - Generated by {fusen} from /dev/severity_index.Rmd: do not edit by hand

#' Build index
#' 
#' This function builds the index. It assumes that at this point you have imported
#' your data and built the coin. Also optionally you have analysed and
#' possibly removed indicators, but taken no further steps.
#' 
#' The operations performed here are:
#' 
#' - Treatment of outliers using a standard Winsorisation/log approach
#' - Normalistion to the 1, 100 interval
#' - Aggregation using one of the methods specified by `agg_method`
#' 
#' The output is an updated coin.
#' 
#' NOTE that for the Compind-powered aggregation methods, we need to be careful
#' about how the aggregated values are rescaled or not in the case of a single
#' indicator in an aggregation group. I initially blocked single-indicator groups
#' here but relaxed this after adjusting the aggregation wrapper functions.
#' 
#' @param coin The coin.
#' @param agg_method One of `"a_amean"` (arithmetic mean), `"a_gmean"` (geometric mean),
#' `"a_bod"` (benefit of doubt via Compind package) or `"a_wroclaw"` (Wroclaw Taxonomic Method via Compind).
#' @param max_winsorisation   default is 5,
#' @param skew_thresh default is  2,
#' @param kurt_thresh default is  3.5
#'              
#' @importFrom COINr is.coin qTreat Normalise Aggregate
#' 
#' @return coin Updated coin.
#' 
#' @export
#' @examples
#' MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
#'                                             package = "BuildIndex") )
#' 
#' MVI1 <- f_build_index(coin = MVI, 
#'                      agg_method = "a_amean", #   (arithmetic mean),
#'                      max_winsorisation = 5,
#'                      skew_thresh = 2,
#'                      kurt_thresh = 3.5)
#' 
#' MVI2 <- f_build_index(coin = MVI, 
#'                      agg_method = "a_gmean", # (geometric mean),
#'                      max_winsorisation = 5,
#'                      skew_thresh = 2,
#'                      kurt_thresh = 3.5)
#' 
#' MVI3 <- f_build_index(coin = MVI, 
#'                      agg_method = "a_bod", # (benefit of doubt via Compind package) 
#'                      max_winsorisation = 5,
#'                      skew_thresh = 2,
#'                      kurt_thresh = 3.5)
#' 
#' MVI4 <- f_build_index(coin = MVI, 
#'                      agg_method = "a_wroclaw", # (Wroclaw Taxonomic Method via Compind)
#'                      max_winsorisation = 5,
#'                      skew_thresh = 2,
#'                      kurt_thresh = 3.5)
f_build_index <- function(coin, 
                          agg_method = "a_amean",
                          max_winsorisation = 5,
                          skew_thresh = 2,
                          kurt_thresh = 3.5){

  stopifnot(COINr::is.coin(coin))
  
  # # If bod method, we can't proceed if any groups with only one child (throws error in compind)
  # if(agg_method %in% c("a_bod", "a_wroclaw")){
  #   solo_groups <- get_solo_groups(coin)
  #   if(length(solo_groups) > 1){
  #     rlang::abort(
  #       paste0(
  #         c("Cannot use benefit of doubt or Wroclaw methods because some framework groups have only one child: ", solo_groups),
  #         collapse = " "))
  #   }
  # }

  # Settings


  # treat outliers
  coin <- COINr::qTreat(coin, 
                        dset = "Raw",
                        winmax = max_winsorisation,
                        skew_thresh = skew_thresh,
                        kurt_thresh = kurt_thresh,
                        f2 = "log_CT_plus")

  # normalise to [1, 100]: otherwise if we have zeros can't use geometric mean
  coin <- COINr::Normalise(
    coin, 
    dset = "Treated",
    global_specs = list(f_n = "n_minmax",
                        f_n_para = list(l_u = c(1, 100)))
  )

  # AGGREGATE
  
  # some methods don't require weights input
  if(agg_method %in% c("a_bod", "a_wroclaw")){
    w <- "none"
    by_df <- TRUE
  } else {
    w <- NULL
    by_df <- FALSE
  }
  
  coin <- COINr::Aggregate(coin, dset = "Normalised", f_ag = agg_method, w = w, by_df = by_df)

  # generate results tables
  coin <- f_generate_results(coin)

  return(coin)
    
}
