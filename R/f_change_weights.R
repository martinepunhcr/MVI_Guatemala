# WARNING - Generated by {fusen} from /dev/severity_index.Rmd: do not edit by hand

#' Change weights
#' 
#' Function that takes some new weights and regenerates the coin. Results are
#' regenerated from the aggregation step only, so all previously-specified methodology
#' is fixed.
#' 
#'
#' @param coin The coin.
#' @param w weight. The weights `w` can either be a named list with names as iCodes
#'           and values the new weights, OR 
#'           as a data frame with columns "iCode" and "Weight" with 
#'           codes and corresponding weights.   
#'           In both cases a subset of weight-code pairs can be specified.
#'          E.g. `list("Salud" = 0.5, Amenazas = 0.8)`.
#' 
#'          OR set `w = "equal"` for equal weights everywhere, or `w = "original"` to use the
#'           weights that were input with the input data.
#' 
#'           Remember that weights are relative within aggregation groups.
#'                   
#' @importFrom COINr is.coin Regen
#' @importFrom rlang abort
#' 
#' @return Updated coin.
#' 
#' @export
#' @examples
#' MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
#'                                             package = "BuildIndex") )
#' 
#' MVI <- f_build_index(MVI)
#' MVI2 <- f_change_weights(MVI, w= list(Amenazas = 1.5, Cap_Resp = 0.5))
#' 
#' # we can use a COINr function for a comparison
#' COINr::compare_coins(MVI, MVI2, dset = "Aggregated", iCode = "MVI") |>
#'   head()
f_change_weights <- function(coin, w){

  stopifnot(COINr::is.coin(coin))

  if(is.null(coin$Data$Aggregated)){
    rlang::abort("Can't find results in the coin. Did you forget to build the index first?")
  }

  # Get weights that were last used to aggregate ----

  # special case: reset or make equal
  if(is.character(w)){

    stopifnot(length(w) == 1)

    if(w == "equal"){
      w_new <- f_get_equal_weights(coin)
    } else if (w == "original"){
      w_new <- coin$Meta$Weights$Original
    }

    coin$Log$Aggregate$w <- w_new
    return(COINr::Regen(coin, from = "Aggregate"))
  }

  w_new <- f_get_last_weights(coin)

  # Alter weights based on input type ----

  if(is.data.frame(w)){

    stopifnot(all(c("iCode", "Weight") %in% names(w)),
              all(w$iCode %in% w_new$iCode),
              is.numeric(w$Weight))

    # subst new weights in
    w_new$Weight[match(w$iCode, w_new$iCode)] <- w$Weight

  } else if (is.list(w)){

    stopifnot(all(names(w) %in% w_new$iCode),
              all(sapply(w, is.numeric)),
              all(lengths(w) == 1))

    # subst new weights in
    w_new$Weight[match(names(w), w_new$iCode)] <- as.numeric(w)

  }

  # Regen with new weights ----

  coin$Log$Aggregate$w <- w_new

  # extract analysis
  ind_analysis <- coin$Analysis$Raw
  analysis_exists <- !is.null(ind_analysis)

  coin <- COINr::Regen(coin, from = "Aggregate")

  if(analysis_exists){
    coin$Analysis$Raw <- ind_analysis
  }

  # generate results tables again
  coin <- f_generate_results(coin)

  return(coin)
    
}
