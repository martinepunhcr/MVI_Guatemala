# WARNING - Generated by {fusen} from /dev/severity_index.Rmd: do not edit by hand

#' Change weights
#' 
#' Function that takes some new weights and regenerates the coin.
#' 
#'
#' @param coin COIN object, or list with first entry is the indicator metadata, 
#'              second entry is the aggregation metadata
#' @param w weight. The weights `w` can either be a named list with names as iCodes
#'           and values the new weights, OR 
#'           as a data frame with columns "iCode" and "Weight" with 
#'           codes and corresponding weights.   
#'           In both cases a subset of weight-code pairs can be specified.
#'          E.g. `list("Salud" = 0.5, Amenazas = 0.8)`.
#' 
#'          OR set w = "equal" for equal weights everywhere, or w = "original" to use the
#'           weights that were input with the input data.
#' 
#'           Remember that weights are relative within aggregation groups.          
#' @importFrom COINr is.coin Regen
#' @importFrom rlang abort
#' @return coin COIN object
#' 
#' @export
#' @examples
#' MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
#'                                             package = "BuildIndex") )
#' 
#' ## when using create a data-raw folder and put you data input xlsx file there
#' # MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
#' MVI2 <- f_analyse_indicators(coin = MVI)
#' MVI3 <- f_build_index(coin = MVI2)
#' MVI4 <- f_change_weights(coin = MVI3, w= list(Amenazas = 2, Cap_Resp = 0.5))
#' MVI4
f_change_weights <- function(coin, w){

  stopifnot(COINr::is.coin(coin))

  if(is.null(coin$Data$Aggregated)){
    rlang::abort("Can't find results in the coin. Did you forget to build the index first?")
  }

  # Get weights that were last used to aggregate ----

  # special case: reset or make equal
  if(is.character(w)){

    stopifnot(length(w) == 1)

    if(w == "equal"){
      w_new <- f_get_equal_weights(coin)
    } else if (w == "original"){
      w_new <- coin$Meta$Weights$Original
    }

    coin$Log$Aggregate$w <- w_new
    return(COINr::Regen(coin, from = "Aggregate"))
  }

  w_new <- f_get_last_weights(coin)

  # Alter weights based on input type ----

  if(is.data.frame(w)){

    stopifnot(all(c("iCode", "Weight") %in% names(w)),
              all(w$iCode %in% w_new$iCode),
              is.numeric(w$Weight))

    # subst new weights in
    w_new$Weight[match(w$iCode, w_new$iCode)] <- w$Weight

  } else if (is.list(w)){

    stopifnot(all(names(w) %in% w_new$iCode),
              all(sapply(w, is.numeric)),
              all(lengths(w) == 1))

    # subst new weights in
    w_new$Weight[match(names(w), w_new$iCode)] <- as.numeric(w)

  }

  # Regen with new weights ----

  coin$Log$Aggregate$w <- w_new

  # extract analysis
  ind_analysis <- coin$Analysis$Raw
  analysis_exists <- !is.null(ind_analysis)

  coin <- COINr::Regen(coin, from = "Aggregate")

  if(analysis_exists){
    coin$Analysis$Raw <- ind_analysis
  }

  # generate results tables again
  coin <- f_generate_results(coin)

  return(coin)
    
}
