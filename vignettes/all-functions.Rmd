---
title: "All functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{all-functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(BuildIndex)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/severity_index.Rmd: do not edit by hand -->

This document gives some notes on the development of the "code modules" for Index Development. 

These code modules are envisaged to be chunks of code which deal with particular tasks in the construction of the index. 

The modules are intended to comprise (most of) the back end code of an eventual user application which can be used to construct similar indices to the index for other countries. 

This means that the modules have to be focused, and robust.

There are 5 modules.

- Data input
- Indicator analysis and selection
- Index construction and visualisation
- Reweighting
- Export


# DEMO DATA

The demo dataset comes from Guatemala


```{r}

## Adding demo data based on Guatemala

# Run all this chunk in the console directly
# Create "inst/" directory
#dir.create(here::here("inst"))

# Example dataset
# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
example <- system.file("data_input/data_module-input.xlsx", package = "BuildIndex") 


#data_module-input.xlsx
  # coin <- f_data_input(here::here("inst/data_input", "data_module-input.xlsx"))
  # 
  # coin <- f_analyse_indicators(coin)
  # 
  # coin <- f_remove_indicators(coin, c("S.G.3", "A.M.1"))
  # 
  # coin <- f_build_index(coin)
  # 
  # coin <- f_change_weights(coin, w = list(Amenazas = 2, Cap_Resp = 0.5))
```

# MODULE 1: DATA INPUT

**Objective**: To allow the user to input their data, which can then be used for the rest of the analysis.

**Input(s)**: The only input here will be the input file. I think and Excel spreadsheet should be sufficient.

**Output(s)**

- Front end: confirmation of successful data entry, or else helpful error messages. Summary of what was input, e.g. number of indicators, number of units. Possibly a framework plot and/or a table of data.
- Back end: An assembled coin.

**Notes**

- The input will have to be carefully constrained by using e.g. an Excel spreadsheet with a template that is quite restrictive of how users enter their data. I can also put some checks in Excel, e.g. to ensure numerical columns, etc. This template I think can be properly developed in the next contract/phase.
- When data is uploaded into R, I will have to construct the iMeta and iData inputs, using a saved iMeta which defines the index structure
- Will have to deal with any categories/dimensions that have no indicators in prior to assembling coin
- We will need strict checks on unit codes if we want to use maps. E.g. unit codes are *required* to be those used as second level administrative divisions (admin2).
- Do we need a units column?




## Data input

    

  

```{r example-f_data_input}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

```

  

  
  

## Print coin

    

  

```{r example-f_print_coin}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
f_print_coin(MVI)
```

  

  
  

## f_plot_framework

    

  

```{r example-f_plot_framework}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
f_plot_framework(MVI)
```

  

      


# MODULE 2: Indicator analysis and selection

**Objective**: To flag any statistical issues with indicators and allow the user to remove indicators if they want to (without having to edit their input file).

**Input(s)**: This will be a two-stage process: the analysis and the indicator selection. For the former there is no input. For the latter the input will be any indicators to remove. In the code this will be a vector of indicator codes, but in app it will be selected interactively.

**Output(s)**

- Front: Analysis table at first step (as DT), probably a framework plot for the second. Details of indicators removed. We may also need e.g. box plot and/or scatter plot to help users visualise (tbd).
- Back: Analysis table as data frame, then modified coin after removal of indicators, if any. Modified coin.

**Notes**

- Thinking ahead, we'll have to figure out what the best way to inform the user is when removing indicators. I would say maybe the framework plot here and maybe some before/after stats.
- We will need to keep a record of which indicators were removed. In the app, we will need to save the indicator flags table somewhere so that it is also exported when everything else is.


## Analyse indicators

    

  

```{r example-f_analyse_indicators}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
f_analyse_indicators(MVI)
```

  

  

## Gather correlations

    

  

```{r example-f_gather_correlations}
#f_gather_correlations()
```

  

## Display indicator analysis

    

  

```{r example-f_display_indicator_analysis}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

MVI2 <- f_analyse_indicators(MVI)

f_display_indicator_analysis(MVI2)
```

  

  
  

## Highlight Data Table

    

  

```{r example-f_highlight_DT}
#f_highlight_DT()
```

  

  

## Remove indicators

    

  

```{r example-f_remove_indicators}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
MVI2 <- f_analyse_indicators(MVI)
MVI3 <- f_remove_indicators(MVI2, c("S.G.3", "A.M.1"))
MVI3
```

  

    
        

## Add indicators

    

  

```{r example-f_add_indicators}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

f_add_indicators(MVI)
```

  

  


# MODULE 3: Index construction and visualisation

**Objective**: To build the index from the indicators selected in the previous step and show the results as table/map/bar chart.

**Input(s)**: Possibly none from the user. If the methodology is fixed, there is no need for any input except perhaps which visualisation to use.

**Output(s)**

- Front: Results table, bar chart, map
- Back: Modified coin.

**Notes**

The only thing to decide here is whether to give the user any control over the methodology. Essentially we *could* offer control at the treatment, normalisation or aggregation stages. However this would make things more confusing and also mean departing from a standardised methodology. The only case possibly worth considering is the outlier treatment for fringe cases which could cause an error. Another possibility is that we automate the data treatment so in case there is an error, that indicator is reverted back to its original state.


## Build index

    

  

```{r example-f_build_index}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

f_build_index(coin = MVI)
```

  

  

## Display results table

    

  

```{r example-f_display_results_table}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

MVI2 <- f_build_index(coin = MVI)
f_display_results_table(coin = MVI2)
```

  

## Plot map

    

  

```{r example-f_plot_map}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

MVI2 <- f_build_index(coin = MVI)

f_plot_map(coin = MVI2, 
           dset = "Aggregated",
           iCode = "MVI", 
           shp_path = system.file("shp/gtm_admbnda_adm2_ocha_conred_20190207.shp",
                                            package = "BuildIndex")  )
## when using ut your shape in the folder ---
         #  shp_path = here::here("inst/shp", "gtm_admbnda_adm2_ocha_conred_20190207.shp")           )
```

  

      

## Generate results

    

  

```{r example-f_generate_results}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))

MVI2 <- f_build_index(coin = MVI)

f_generate_results(coin = MVI2)
```

  

  


# MODULE 4: Reweighting

**Objective**: To allow users to adjust weights manually to their preferences, and see the results interactively change.

**Input(s)**: Weights - which can be just at dimension level, or at dimension and category level. Would not recommend allowing indicator-level adjustment because it would result in a messy UI and probably confusion for the user.

**Output(s)**

- Front: Table of results. Possibly compared side by side with the un-altered results.
- Back: Modified coin plus data frame output of results.

**Notes**

- The question is: when a user adjusts weights do we retain a parallel copy of the index with the original weights which can be used for comparison? Or should everything update? I think possibly the latter if we want to keep the weight adjustment on the same tab as the results visualisations.
- We will anyway need a reset button to reset to original weights.


## Change weights

    

  

```{r example-f_change_weights}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
MVI2 <- f_analyse_indicators(coin = MVI)
MVI3 <- f_build_index(coin = MVI2)
MVI4 <- f_change_weights(coin = MVI3, w= list(Amenazas = 2, Cap_Resp = 0.5))
MVI4
```

  

  

## Get equal weights

    

  

```{r example-f_get_equal_weights}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
MVI2 <- f_analyse_indicators(coin = MVI)
MVI3 <- f_remove_indicators(coin = MVI2, c("S.G.3", "A.M.1"))
MVI4 <- f_build_index(coin = MVI3)
weight <- f_get_equal_weights(coin = MVI4)
weight
```

  

  
  

## Get last weights

    

  

```{r example-f_get_last_weights}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
MVI2 <- f_analyse_indicators(MVI)
MVI3 <- f_build_index(coin = MVI2)
weight <- f_get_last_weights(MVI3)
weight 
```

  

      



# MODULE 5: Export

**Objective**: To export all results to Excel.

**Input(s)**: Just the command to export.

**Output(s)**

- Front: An Excel spreadsheet with results.
- Back: None

**Notes**

COINr has a function to export to Excel. However we will need to adjust this because it currently outputs everything in the coin. Instead we want a simplified output which has the main results, a record of which indicators were selected, weights used, and probably the data sets generated at each construction stage for the record.

In more detail let's say we probably want the following:

- Results table (scores)
- Results table (ranks)
- Analysis table
- Indicators included: possibly the lineage table
- Weights used
- Data sets at each stage


## Export to excel

    

  

```{r example-f_export_to_excel}
MVI <- f_data_input(file_path = system.file("data_input/data_module-input.xlsx",
                                            package = "BuildIndex") )

## when using create a data-raw folder and put you data input xlsx file there
# MVI <- f_data_input(here::here("data-raw", "data_module-input.xlsx"))
MVI2 <- f_analyse_indicators(coin = MVI)
MVI3 <- f_build_index(coin = MVI2)

f_export_to_excel(coin = MVI3, 
                  fname = here::here("inst", "index_export.xlsx"))
```

  

  

# Generate technical report

    

  

```{r example-f_export_report}
f_export_report()
```

  

    
  
  
  


